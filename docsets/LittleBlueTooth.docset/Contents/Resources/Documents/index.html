<!DOCTYPE html>
<html lang="en">
  <head>
    <title>LittleBlueTooth  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="LittleBlueTooth  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
          LittleBlueTooth Docs
        </a>
         (70% documented)
      </p>
    
      <div class="header-col--secondary">
        <form role="search" action="search.json">
          <input type="text" placeholder="Search documentation" data-typeahead>
        </form>
      </div>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/DrAma999">
            <img class="header-icon" src="img/gh.png" alt="GitHub"/>
            View on GitHub
          </a>
        </p>
    
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">LittleBlueTooth Reference</a>
      <img class="carat" src="img/carat.png" alt=""/>
      LittleBlueTooth  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/LittleBlueTooth.html">LittleBlueTooth</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Peripheral.html">Peripheral</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ReplaySubject.html">ReplaySubject</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ReplaySubjectSubscription.html">ReplaySubjectSubscription</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Global%20Variables.html">Global Variables</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataIsConnectable">CBAdvertisementDataIsConnectable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataLocalNameKey">CBAdvertisementDataLocalNameKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataManufacturerDataKey">CBAdvertisementDataManufacturerDataKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataOverflowServiceUUIDsKey">CBAdvertisementDataOverflowServiceUUIDsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataServiceDataKey">CBAdvertisementDataServiceDataKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataServiceUUIDsKey">CBAdvertisementDataServiceUUIDsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataSolicitedServiceUUIDsKey">CBAdvertisementDataSolicitedServiceUUIDsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBAdvertisementDataTxPowerLevelKey">CBAdvertisementDataTxPowerLevelKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerOptionRestoreIdentifierKey">CBCentralManagerOptionRestoreIdentifierKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerOptionShowPowerAlertKey">CBCentralManagerOptionShowPowerAlertKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerRestoredStatePeripheralsKey">CBCentralManagerRestoredStatePeripheralsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerRestoredStateScanOptionsKey">CBCentralManagerRestoredStateScanOptionsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerRestoredStateScanServicesKey">CBCentralManagerRestoredStateScanServicesKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerScanOptionAllowDuplicatesKey">CBCentralManagerScanOptionAllowDuplicatesKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBCentralManagerScanOptionSolicitedServiceUUIDsKey">CBCentralManagerScanOptionSolicitedServiceUUIDsKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBConnectPeripheralOptionNotifyOnConnectionKey">CBConnectPeripheralOptionNotifyOnConnectionKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBConnectPeripheralOptionNotifyOnDisconnectionKey">CBConnectPeripheralOptionNotifyOnDisconnectionKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBConnectPeripheralOptionNotifyOnNotificationKey">CBConnectPeripheralOptionNotifyOnNotificationKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/CBConnectPeripheralOptionStartDelayKey">CBConnectPeripheralOptionStartDelayKey</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global%20Variables.html#/s:15LittleBlueTooth05StartabC0s6ResultO7CombineE9PublisherVyytAA0A14BluetoothErrorO_Gvp">StartLittleBlueTooth</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/BluetoothState.html">BluetoothState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ConnectionEvent.html">ConnectionEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/LittleBluetoothError.html">LittleBluetoothError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/PeripheralChanges.html">PeripheralChanges</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/PeripheralState.html">PeripheralState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/Restored.html">Restored</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/CBMPeripheral.html">CBMPeripheral</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Data.html">Data</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/OSLog.html">OSLog</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Publisher.html">Publisher</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/TimeInterval.html">TimeInterval</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UInt8.html">UInt8</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/PeripheralIdentifiable.html">PeripheralIdentifiable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Readable.html">Readable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Writable.html">Writable</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/AdvertisingInfo.html">AdvertisingInfo</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/CentralRestorer.html">CentralRestorer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/LittleBlueToothCharacteristic.html">LittleBlueToothCharacteristic</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/LittleBlueToothCharacteristic/Properties.html">– Properties</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/LittleBluetoothConfiguration.html">LittleBluetoothConfiguration</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/PeripheralDiscovery.html">PeripheralDiscovery</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/PeripheralIdentifier.html">PeripheralIdentifier</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:15LittleBlueTooth21AutoconnectionHandlera">AutoconnectionHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBATTError">CBATTError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCentralManager">CBCentralManager</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCentralManagerDelegate">CBCentralManagerDelegate</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCentralManagerFactory">CBCentralManagerFactory</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCharacteristic">CBCharacteristic</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCharacteristicProperties">CBCharacteristicProperties</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBCharacteristicWriteType">CBCharacteristicWriteType</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBConnectionEvent">CBConnectionEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBConnectionEventMatchingOption">CBConnectionEventMatchingOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBDescriptor">CBDescriptor</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBError">CBError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBManagerState">CBManagerState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBPeripheral">CBPeripheral</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBPeripheralDelegate">CBPeripheralDelegate</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBPeripheralState">CBPeripheralState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBService">CBService</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/CBUUID">CBUUID</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:15LittleBlueTooth0abC25CharacteristicIndentifiera">LittleBlueToothCharacteristicIndentifier</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:15LittleBlueTooth0abC18ServiceIndentifiera">LittleBlueToothServiceIndentifier</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content top-matter">
            
            <p align="center">
  <img width="200" height="200" src="README/Icon.png">
</p>

<p><img src="https://img.shields.io/static/v1?label=platforms&message=iOS13|macOS10.15|watchOS6.0|tvOS13&color=black"></p> <p><img src="https://img.shields.io/static/v1?label=carthage&message=compatible&color=green"> <img src="https://img.shields.io/static/v1?label=SwiftPM&message=compatible&color=green"></p>

<p><img src="https://github.com/DrAma999/LittleBlueTooth/workflows/Swift/badge.svg?branch=master" alt="Swift">
<a href="https://www.codefactor.io/repository/github/drama999/littlebluetooth"><img src="https://www.codefactor.io/repository/github/drama999/littlebluetooth/badge" alt="CodeFactor"></a>
<a href="https://codecov.io/gh/DrAma999/LittleBlueTooth"><img src="https://codecov.io/gh/DrAma999/LittleBlueTooth/branch/master/graph/badge.svg" alt="codecov"></a></p>
<h1 id='little-bluetooth' class='heading'>LITTLE BLUETOOTH</h1>
<h2 id='introduction' class='heading'>INTRODUCTION</h2>

<p>LittleBluetooth is a library that helps you developing applications that need to work with a bluetooth low energy device.
It is written using <code>Swift</code> and the <code>Combine</code> framework thus is only compatible from iOS 13, macOS 10.15, watchOS 6.0 to upper version.
It will make pretty easy to work with CoreBlueTooth: connecting to a peripheral and reading a characteristic can be mabe with just these lines of code:</p>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
.startDiscovery(for: self.littleBT, withServices: [CBUUID(string: HRMCostants.HRMService)])
.prefix(1)
.connect(for: self.littleBT)
.read(for: self.littleBT, from: hrmSensorChar)
.sink(receiveCompletion: { (result) in
    print("Result: \(result)")
    switch result {
    case .finished:
        break
    case .failure(let error):
        print("Error while changing sensor position: \(error)")
        break
    }

}) { (value: HeartRateSensorPositionResponse) in // Specify the concrete type
    print("Value: \(value)")
}
.store(in: &amp;disposeBag)
</code></pre>

<p>An instance of LittleBluetooth can control only one peripheral, you can use more instances as many peripheral you need, but first read this <a href="https://developer.apple.com/forums/thread/20810">answer</a> on Apple forums to understand the impact of having more <code><a href="Typealiases.html#/CBCentralManager">CBCentralManager</a></code> instances.</p>

<p>The library is still on development so use at own you risk.</p>
<h2 id='toc' class='heading'>TOC</h2>

<p><a href="#features">Features</a></p>

<p><a href="#installation">Installation</a></p>

<p><a href="#how-to-use-it">How to use it</a></p>

<ul>
<li><a href="#instantiate">Instantiate</a></li>
<li><a href="#scan">Scan</a></li>
<li><a href="#connect">Connect</a></li>
<li><a href="#read">Read</a></li>
<li><a href="#write">Write</a></li>
<li><a href="#listen">Listen</a></li>
<li><a href="#disconnection">Disconnection</a></li>
<li><a href="#connection-event-observer">Connection event observer</a></li>
<li><a href="#initialization-operations">Initialization operation</a></li>
<li><a href="#Autoconnection">Autoconnection</a></li>
<li><a href="#state-preservation-and-state-restoration">State preservation and restoration</a></li>
<li><a href="#cbcentralmanager-cbperipheral-extraction">Central manager extraction</a></li>
</ul>

<p><a href="#custom-combine-operator">Custom operators</a></p>

<p><a href="#documentation">Documentation</a></p>

<p><a href="#sample-application">Sample application</a></p>

<p><a href="#license">License</a></p>
<h2 id='features' class='heading'>FEATURES</h2>

<ul>
<li>Built on top of Combine</li>
<li>Deploys on <strong>iOS, macOS, macOS (Catalyst), tvOS, watchOS</strong></li>
<li>Chainable operations: scan, connect, enable listen, disable listen and read/write . Each operation is executed serially without having to worry in dealing with delegates</li>
<li>Peripheral state and bluetooth state observation. You can watch the bluetooth state and also the peripheral states for a more fine grained control in the UI. Those information are also checked before starting any operation.</li>
<li>Single notification channel: you can subscribe to the notification channel to receive all the data of the enabled characteristics. You have also single and connectable publishers.</li>
<li>Write and listen (or better listen and write): sometimes you need to write a command and get a “response” right away</li>
<li>Initialization operations: sometimes you want to perform some bluetooth commands right after a connection, for instance an authentication, and you want to perform that before another operation have access to the peripheral.</li>
<li>Readable and Writable characteristics: basically those two protocols will deal in reading a <code>Data</code> object to the concrete type you want or writing your concrete type into a <code>Data</code> object.</li>
<li>Simplified <code>Error</code> normalization and if you need more information you can always access the inner <code><a href="Typealiases.html#/CBError">CBError</a></code></li>
<li>Code coverage &gt; 90%</li>
</ul>
<h2 id='installation' class='heading'>INSTALLATION</h2>
<h3 id='carthage' class='heading'>Carthage</h3>

<p>Add the following to your Cartfile:</p>
<pre class="highlight plaintext"><code>github "DrAma999/LittleBlueTooth" ~&gt; 0.7.1
</code></pre>

<p>Since the framework supports most of the Apple devices, you probably want to to build for a specific platform by adding the option <code>--platform</code> after the <code>carthage update</code> command. For instance:</p>
<pre class="highlight plaintext"><code>carthage update --platform iOS`
</code></pre>

<p><em>This step is super-optional:</em>
The library has a sub-dependency with Nordic library <a href="https://github.com/NordicSemiconductor/IOS-CoreBluetooth-Mock">Core Bluetooth Mock</a> that helped me in creating unit tests, if you want to launch unit tests you must add this to your Cartfile and use the <code>LittleBlueToothForTest</code> product instead of  <code><a href="Classes/LittleBlueTooth.html">LittleBlueTooth</a></code>, note that this target is made only to run tests by using mocks.</p>
<h3 id='swift-package-manager' class='heading'>Swift Package Manager</h3>

<p>Add the following dependency to your Package.swift file:</p>
<pre class="highlight plaintext"><code>.package(url: "https://github.com/DrAma999/LittleBlueTooth.git", from: "0.7.1")
</code></pre>

<p>Or simply add the URL from XCode menu Swift packages.</p>
<h3 id='xcframework' class='heading'>XCFramework</h3>

<p>Already compiled XCFramework are avaible to be download in the release section of github.</p>
<h2 id='how-to-use-it' class='heading'>HOW TO USE IT</h2>
<h3 id='instantiate' class='heading'>Instantiate</h3>

<p>Create a <code><a href="Structs/LittleBluetoothConfiguration.html">LittleBluetoothConfiguration</a></code> object and pass it to the init method of <code><a href="Classes/LittleBlueTooth.html">LittleBlueTooth</a></code>.
All <code><a href="Structs/LittleBluetoothConfiguration.html">LittleBluetoothConfiguration</a></code> properties are optional.</p>
<pre class="highlight plaintext"><code>    var littleBTConf = LittleBluetoothConfiguration()
    littleBT = LittleBlueTooth(with: littleBTConf)
</code></pre>
<h3 id='scan' class='heading'>Scan</h3>

<p>You can scan with or without a timeout, after a timeout you receive a <code>.scanTimeout</code> error. 
You can set up your timeout for each sort of operation, for instance for a scan:</p>
<pre class="highlight plaintext"><code>anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
.timeout(DispatchQueue.SchedulerTimeType.Stride(timeout.dispatchInterval), scheduler: DispatchQueue.main, options: nil, error: .scanTimeout)
</code></pre>

<p>Note that each peripheral found is published to the subscribers chain until you stop the scan request or you connect to a device (when you connect scan is automatically suspended.</p>

<p><em>Scan and stop</em>:</p>
<pre class="highlight plaintext"><code>        // Remember that the AnyCancellable resulting from the `sink` must have a strong reference
        // Also pay attention to eventual retain cycles
        anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
        .filter { (discovery) -&gt; Bool in
            print("discovery \(discovery)")
            if let name = discovery.advertisement.localName, name == "PunchLX" {
                return true
            }
            return false
        }
        .flatMap{ (discovery) -&gt; AnyPublisher&lt;PeripheralDiscovery, LittleBluetoothError&gt; in
            print("Discovery: \(discovery)")
            return self.littleBT.stopDiscovery()map {discovery}.eraseToAnyPublisher()
        }
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                // Handle errors
                print("Error: \(error)")
            }
        }, receiveValue: { (periph) in
            print("Discovered Peripheral \(periph)")
        })
</code></pre>

<p><em>Scan with connection</em>:</p>

<p>The scan process is automatically stopped once you start the connection command.</p>
<pre class="highlight plaintext"><code>        // Remember that the AnyCancellable resulting from the `sink` must have a strong reference
        // Also pay attention to eventual retain cycles
        anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
        .filter { (discovery) -&gt; Bool in
            print("discovery \(discovery)")
            if let name = discovery.advertisement.localName, name == "PunchLX" {
                return true
            }
            return false
        }
        .flatMap { (discovery)-&gt; AnyPublisher&lt;Peripheral, LittleBluetoothError&gt; in
            self.littleBT.connect(to: discovery)
        }
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                // Handle errors
            }
        }, receiveValue: { (periph) in
            print("Connected Peripheral \(periph)")
        })
</code></pre>

<p><em>Scan with peripherals buffer</em>:</p>
<pre class="highlight plaintext"><code>        // Remember that the AnyCancellable resulting from the `sink` must have a strong reference
        // Also pay attention to eventual retain cycles
        anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
        .collect(10)
        .map{ (discoveries) -&gt; AnyPublisher&lt;[PeripheralDiscovery], LittleBluetoothError&gt; in
            print("Discoveries: \(discoveries)")
            return self.littleBT.stopDiscovery().map {discoveries}.eraseToAnyPublisher()
        }
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                // Handle errors
                print("Error: \(error)")
            }
        }, receiveValue: { (peripherals) in
            print("Discovered Peripherals \(peripherals)")
        })
</code></pre>
<h3 id='connect' class='heading'>Connect</h3>

<p><em>Connection from discovery</em>:</p>

<p>A <code><a href="Structs/PeripheralDiscovery.html">PeripheralDiscovery</a></code> is a representation of what you usually get from a scan, it has the <code>UUID</code> of the peripheral and the advertising info.</p>
<pre class="highlight plaintext"><code>        // Taken a discovery from scan
        anycanc = self.littleBT.connect(to: discovery)
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                // Handle errors
            }
        }, receiveValue: { (periph) in
            print("Connected Peripheral \(periph)")
        })
</code></pre>

<p><em>Direct connection from peripheral identifier</em>:</p>

<p><code><a href="Structs/PeripheralIdentifier.html">PeripheralIdentifier</a></code> is a wrapper around a <code><a href="Typealiases.html#/CBPeripheral">CBPeripheral</a></code> identifier, this allows you to connect to a peripheral just knowing the <code>UUID</code> of the peripheral.</p>
<pre class="highlight plaintext"><code>
         anycanc = self.littleBT.connect(to: peripheralIs)
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                // Handle errors
            }
        }, receiveValue: { (periph) in
            print("Connected Peripheral \(periph)")
        })
</code></pre>
<h3 id='read' class='heading'>Read</h3>

<p><em>Reading from a characteristic</em>:</p>

<p>To read from a characteristic first you have to create an instance of <code>LittleBluetoothCharacteristic</code> and define the data you want to read.</p>
<pre class="highlight plaintext"><code>let littleChar = LittleBlueToothCharacteristic(characteristic: "19B10011-E8F2-537E-4F6C-D104768A1214", for: "19B10010-E8F2-537E-4F6C-D104768A1214")
</code></pre>

<p>The class or struct that you want to read must conform to the <code><a href="Protocols/Readable.html">Readable</a></code>
protocol, basically it means that it can be instantiated from a <code>Data</code> object.</p>

<p>For example here I’m declaring and <code>Acceleration</code> struct that contains acceleration data from a sensor.</p>
<pre class="highlight plaintext"><code>struct Acceleration: Readable {
    let measureAx: Float
    let measureAy: Float
    let measureAz: Float
    let measureGx: Float
    let measureGy: Float
    let measureGz: Float

    let timestamp: TimeInterval

    init(from bluetoothData: Data) throws {
        let timeInt: UInt32 = try bluetoothData.extract(start: 0, length: 4)
        timestamp = TimeInterval(exactly: timeInt.littleEndian)! / 1000.0
        var measureInt: Int16 = try bluetoothData.extract(start: 4, length: 2)
        measureAx = Float(measureInt.littleEndian) / 100.0
        measureInt = try bluetoothData.extract(start: 6, length: 2)
        measureAy = Float(measureInt.littleEndian) / 100.0
        measureInt = try bluetoothData.extract(start: 8, length: 2)
        measureAz = Float(measureInt.littleEndian) / 100.0
        var measureGyroInt: Int32 = try bluetoothData.extract(start: 10, length: 4)
        measureGx = Float(measureGyroInt.littleEndian) / 100.0
        measureGyroInt = try bluetoothData.extract(start: 14, length: 4)
        measureGy = Float(measureGyroInt.littleEndian) / 100.0
        measureGyroInt = try bluetoothData.extract(start: 18, length: 4)
        measureGz = Float(measureGyroInt.littleEndian) / 100.0
    }

}
</code></pre>

<p>After that, is just a matter of call the read method.</p>
<pre class="highlight plaintext"><code>        anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
        .filter { (discovery) -&gt; Bool in
            if let name = discovery.advertisement.localName, name == "PunchLX" {
                return true
            }
            return false
        }
        .flatMap { (discovery)-&gt; AnyPublisher&lt;Peripheral, LittleBluetoothError&gt; in
            self.littleBT.connect(to: discovery)
        }
        .flatMap{_ -&gt; AnyPublisher&lt;LedState, LittleBluetoothError&gt; in
            self.littleBT.read(from: self.littleChar)
        }
        .sink(receiveCompletion: { result in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                print("Error: \(error)")
                // Handle error
            }
        }, receiveValue: { (acc) in
            print("Read \(acc)")
        })
</code></pre>
<h3 id='write' class='heading'>Write</h3>

<p><em>Writing to a characteristic</em>:</p>

<p>To write to a characteristic first you have to create an instance of <code>LittleBluetoothCharacteristic</code> and define the data you want to read.</p>
<pre class="highlight plaintext"><code>let littleChar = LittleBlueToothCharacteristic(characteristic: "19B10011-E8F2-537E-4F6C-D104768A1214", for: "19B10010-E8F2-537E-4F6C-D104768A1214")
</code></pre>

<p>The class or struct that you want to write must conform to the <code><a href="Protocols/Writable.html">Writable</a></code>
protocol, basically it means that it can be converted to a <code>Data</code> object.</p>

<p>For example here I’m declaring an object that simply turns on and off a LED.</p>
<pre class="highlight plaintext"><code>struct LedState: Writable {
    let isOn: Bool
    var data: Data {
        return isOn ? Data([0x01]) : Data([0x00])
    }
}
</code></pre>

<p>After that is just a matter of call the write publisher.</p>
<pre class="highlight plaintext"><code>littleBT.write(to: charateristic, value: ledState)
</code></pre>

<p><em>WriteAndListen</em>:</p>

<p>Sometimes you need to write a command to a “Control point” and read the subsequent reply from the BT device.
This means attach yourself as a listener to a characteristic, write the command and wait for the reply.
This process has been made super simple by using “write and listen”.</p>
<pre class="highlight plaintext"><code>        anycanc = littleBT.startDiscovery(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey : false])
        .flatMap { discovery in
            self.littleBT.connect(to: discovery)
        }
        .flatMap { _ in
            self.littleBT.writeAndListen(from: littleCharateristic, value: ledState)
        }
        .sink(receiveCompletion: { completion in
            print("Result: \(result)")
            switch result {
            case .finished:
                break
            case .failure(let error):
                print("Error: \(error)")
                // Handle error
            }
        }) { (answer: LedState) in
            print("Answer \(answer)")            
        }
</code></pre>
<h3 id='listen' class='heading'>Listen</h3>

<p>You can listen to a charcteristic in different ways.</p>

<p><em>Listen</em>:</p>

<p>After creating your <code>LittleCharacteristic</code> instance, then send the <code>startListen(from:)</code> and attach the subscriber. Of course the object you want to read must conform the <code><a href="Protocols/Readable.html">Readable</a></code> object.</p>
<pre class="highlight plaintext"><code>anycanc = littleBT.startDiscovery(withServices: [littleChar.service])
.filter { (discovery) -&gt; Bool in
    print("discovery \(discovery)")
    if let name = discovery.advertisement.localName, name == "PunchLX" {
        return true
    }
    return false
}
.flatMap { (discovery)-&gt; AnyPublisher&lt;Peripheral, LittleBluetoothError&gt; in
    self.littleBT.connect(to: discovery)
}
.flatMap{_ -&gt; AnyPublisher&lt;LedState, LittleBluetoothError&gt;in
    self.littleBT.startListen(from: self.littleChar)
}
.sink(receiveCompletion: { result in
    print("Result: \(result)")
}, receiveValue: { (acc) in
    print("Read \(acc)")
})
</code></pre>

<p><strong>Note: if you stop listening to a characteristic, it doesn’t matter if you have more subscribers. The listen process will stop. It’ s up you to provide the business logic to avoid this behavior.</strong></p>

<p><em>Connectable listen</em>:</p>

<p>After creating your <code>LittleCharacteristic</code> instance, then send the <code>connectableListenPublisher(for: valueType:)</code>. Of course the object you want to read must conform the <code><a href="Protocols/Readable.html">Readable</a></code> object.
This is usefull when you want to create more subscribers and attach them later. When you are ready just call the <code>connect()</code> method and notifications will start to stream.</p>
<pre class="highlight plaintext"><code>let connectable = littleBT.connectableListenPublisher(for: charateristic, valueType: ButtonState.self)

// First subscriber
connectable
.sink(receiveCompletion: { completion in
    print("Completion \(completion)")
}) { (answer) in
    print("Sub1 \(answer)")
}
.store(in: &amp;disposeBag)

// Second subscriber
connectable
.sink(receiveCompletion: { completion in
    print("Completion \(completion)")
}) { (answer) in
  print("Sub2: \(answer)")
}
.store(in: &amp;disposeBag)


littleBT.startDiscovery(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey : false])
.map { disc -&gt; PeripheralDiscovery in
    print("Discovery discovery \(disc)")
    return disc
}
.flatMap { discovery in
    self.littleBT.connect(to: discovery)
}
.map { _ -&gt; Void in
    self.cancellable = connectable.connect()
    return ()
}
.sink(receiveCompletion: { completion in
    print("Completion \(completion)")
}) { (answer) in
    print("Answer \(answer)")
}
.store(in: &amp;disposeBag)
</code></pre>

<p><em>Multiple listen</em>:</p>

<p>If you need to receive more notifications on just one subscriber this publisher is made for you.
Just activate one or more notification and subscribe to the <code>listenPublisher</code> publisher.
It starts to stream all notifications once a peripheral is connected automatically.
Now, it&rsquo;s your responsability to filter and converting <code>Data</code> object from <code><a href="Typealiases.html#/CBCharacteristic">CBCharacteristic</a></code> to your type.</p>
<pre class="highlight plaintext"><code>// First publisher
littleBT.listenPublisher
.filter { charact -&gt; Bool in
        charact.id == charateristicOne.id
}
.tryMap { (characteristic) -&gt; ButtonState in
        try characteristic.value()
}
.mapError { (error) -&gt; LittleBluetoothError in
    if let er = error as? LittleBluetoothError {
        return er
    }
    return .emptyData
}
.sink(receiveCompletion: { completion in
        print("Completion \(completion)")
    }) { (answer) in
        print("Sub1: \(answer)")
}
.store(in: &amp;self.disposeBag)

// Second publisher
littleBT.listenPublisher
.filter { charact -&gt; Bool in
        charact.id == charateristicOne.id
}
.tryMap { (characteristic) -&gt; LedState in
    try characteristic.value()
}.mapError { (error) -&gt; LittleBluetoothError in
    if let er = error as? LittleBluetoothError {
        return er
    }
    return .emptyData
}
.sink(receiveCompletion: { completion in
        print("Completion \(completion)")
    }) { (answer) in
        print("Sub2: \(answer)")
}
.store(in: &amp;self.disposeBag)


littleBT.startDiscovery(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey : false])
.map { disc -&gt; PeripheralDiscovery in
        print("Discovery discovery \(disc)")
        return disc
}
.flatMap { discovery in
    self.littleBT.connect(to: discovery)
}
.flatMap { periph in
    self.littleBT.enableListen(from: charateristicOne)
}
.flatMap { periph in
    self.littleBT.enableListen(from: charateristicTwo)
}
.sink(receiveCompletion: { completion in
    print("Completion \(completion)")
}) { (answer) in

}
.store(in: &amp;disposeBag)

</code></pre>
<h3 id='disconnection' class='heading'>Disconnection</h3>

<p>Disconnection can be explicit or unexpected.
Explicit when you call the method:</p>
<pre class="highlight plaintext"><code> self.littleBT.disconnect()
</code></pre>

<p>Unexpected can be due for different reasons: device reset, device out of range etc</p>

<p>Indipendently if it is unexpected or explicit <code><a href="Classes/LittleBlueTooth.html">LittleBlueTooth</a></code> will clean up everything after registering a disconnection.</p>
<h3 id='connection-event-observer' class='heading'>Connection event observer</h3>

<p><em>Connection event observer</em>:</p>

<p>The <code>connectionEventPublisher</code> informs you about what happen while you are connected to a device.
A connection event is defined by different states:</p>

<ul>
<li><code>.connected(CBPeripheral)</code>:  a peripheral was connected after a <code>connect</code> command</li>
<li><code>.autoConnected(CBPeripheral)</code>:  a peripheral was connected automatically, this event is triggered when you use the  <code>autoconnectionHandler</code></li>
<li><code>.ready(CBPeripheral)</code>: this state means that now you can send commands to a peripheral. Why ready and not just connected? because you could have been set some <code>connectionTasks</code> and <em>ready</em> means that, if they where present, they have been executed.</li>
<li><code>.connectionFailed(CBPeripheral, error: LittleBluetoothError?)</code>: when during a connection something goes wrong</li>
<li><code>.disconnected(CBPeripheral, error: LittleBluetoothError?)</code>: when a peripheral ha been disconnected could be from an explicit disconnection or unexpected disconnection</li>
</ul>

<p><em>Peripheral state observer</em>:</p>

<p>It can be used for more fine grained control over peripheral states, they comes from the <code>CBPeripheralStates</code></p>
<h3 id='initialization-operations' class='heading'>Initialization operations</h3>

<p>Sometimes after a connection you need to perform some repetitive task, for instance an authetication by sending a key or a NONCE.
This operations are stored inside the <code>connectionTasks</code> property and excuted after a  normal connection or from an autoconnection. All other operations will be excuted after this has been done.</p>
<h3 id='autoconnection' class='heading'>Autoconnection</h3>

<p>The autoconnection is managed by the <code>autoconnectionHandler</code> handler.
You can inspect the error and decide if an automatic connection is necessary.
If you return <code>true</code> the connection process will start, once the peripheral has been found a connection will be established. If you return <code>false</code> iOS will not try to establish a connection.
Connection process will remain active also in background if the app has the right permission, to cancel just call <code>disconnect</code>.
When a connection will be established an <code>.autoConnected(PeripheralIdentifier)</code> event will be streamed to the <code>connectionEventPublisher</code>
If you want to cancel it you have to send an explicit disconnection.</p>

<p>Autoconnection will be interrupted in these condition:
App Permission | Conditions
&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;-
App has no BT permission to run in bkg | Explicit disconnection, App killed by user/system, when suspended
App has  BT permission to run in bkg | Explicit disconnection, App killed by user/system
App has  BT permission to run in bkg and state restoration enable | Explicit disconnection, App killed by user</p>
<h3 id='state-preservation-and-state-restoration' class='heading'>State preservation and state restoration</h3>

<p>First read Apple documentation <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothBackgroundProcessingForIOSApps/PerformingTasksWhileYourAppIsInTheBackground.html">here</a>, <a href="https://developer.apple.com/library/archive/qa/qa1962/_index.html">here</a> and my article on <a href="https://medium.com/@andrea.alessandro/core-bluetooh-state-preservation-and-restoration-f107031b32fa">Medium</a>.</p>

<p>To make state restoration/preservation work, first you must instantiate <code>LittleBluetTooth</code> with a dictionary that contains for the key <code><a href="Global%20Variables.html#/CBCentralManagerOptionRestoreIdentifierKey">CBCentralManagerOptionRestoreIdentifierKey</a></code> a specific string identifier by using the <code><a href="Structs/LittleBluetoothConfiguration.html">LittleBluetoothConfiguration</a></code> and you must add a handler that it will be called during state restoration. You MUST also opt-in for bluetooth LE accessories in background.
Must be also noted that state restoration works <em>always</em> not only in background, for instance if you kill the application using the swipe, the next time you relaunch it the Central Manager will return the previous state, you must consider that. If you only want  some operations to be run in background, just ask the UIApplication state and apply your business logic.</p>

<p>If your app is woken up by a bluetooh event in background it will call the <code>applicationDidFinishLauching</code> along with a dictionary. Using this key, <code>UIApplicationLaunchOptionsBluetoothCentralsKey</code>, you receive an array of identifiers of CBCentralManager instances that were working before the app was closed. You have a chance to restore the  <code><a href="Classes/LittleBlueTooth.html">LittleBlueTooth</a></code> central manger by extracting the identifer from the launching option dictionary and passing it to the <code>LittleBlueToothConfiguration</code> (or you can simply instantiate using a constant).
If an state restoration event is triggered the handler will receive a <code><a href="Enums/Restored.html">Restored</a></code> object.  A restored object con be a <code><a href="Classes/Peripheral.html">Peripheral</a></code> along with its instance or a scan along with the discovery publisher that will publish all the discovered peripherals. A peripheral will be ruturned even if it is has been disconnected.
To be notified again about peripheral state please subscribe to the <code>connectionEventPublisher</code> only if the peripheral is in a <em>ready</em> state is possible to send other command.</p>

<p>If you don&rsquo;t want LittleBluetooth to manage state restoration, you can subscribe to the <code>restoreStatePublisher</code> publisher, you will receive a <code><a href="Structs/CentralRestorer.html">CentralRestorer</a></code> object that contains all the necessary information to manage state restoration by yourself.
Note:</p>

<ul>
<li>Restoration can happen in background and foreground</li>
<li>The Peripheral object returned can be in different state depending on what has been restored. If a peripheral has been disconnected and an  <code>autoconnectionHandler</code> is provided LittleBluetooth will try to re-establish a connection.</li>
</ul>
<h3 id='cbcentralmanager-cbperipheral-extraction' class='heading'>CBCentralManager CBPeripheral extraction</h3>

<p>Sometimes it could be uselful to extract an already connected peripheral and a central manger and pass them to another framework. For instance if you need to make an OTA firmware update using the nordic library this would be required.
The extraction is made exaclty for this purpuse.</p>
<pre class="highlight plaintext"><code>let extractedState = littleBT.extract() 
</code></pre>

<p>Before extraction you need to stop listen to all the characteristics you where listening to.
The extracted state is a tuple <code>(central: CBCentralManager, peripheral: CBPeripheral?)</code>  that contains the used <code>CBCentralManger</code> and a <code><a href="Typealiases.html#/CBPeripheral">CBPeripheral</a></code> if connected.
You can also <em>restart</em> LittleBlueTooth instance by passing the same object that you have extracted.</p>
<pre class="highlight plaintext"><code>self.littleBT.restart(with: extractedState.central, peripheral: extractedState.peripheral)
</code></pre>
<h2 id='custom-combine-operator' class='heading'>CUSTOM COMBINE OPERATOR</h2>

<p>Most of the functionalities are also wrapped inside custom operators. </p>
<h3 id='scan' class='heading'>Scan</h3>

<p>The constant <code><a href="Global%20Variables.html#/s:15LittleBlueTooth05StartabC0s6ResultO7CombineE9PublisherVyytAA0A14BluetoothErrorO_Gvp">StartLittleBlueTooth</a></code> is a syntatic sugar that helps you prepare the pipeline with correct error type:</p>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
.startDiscovery(for: self.littleBT, withServices: [CBUUID(string: HRMCostants.HRMService)])
.prefix(1)
// ...
</code></pre>

<p>The <code>.startDiscovery</code> operator can return multiple discoveries at different times it&rsquo;s up to you to take the correct results, by collecting, filtering, prefixing  before connecting at the next step.</p>
<h3 id='connect' class='heading'>Connect</h3>

<p>After getting a <code><a href="Structs/PeripheralDiscovery.html">PeripheralDiscovery</a></code> or a <code><a href="Structs/PeripheralIdentifier.html">PeripheralIdentifier</a></code> you can connect to that deveice.</p>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
.startDiscovery(for: self.littleBT, withServices: [CBUUID(string: HRMCostants.HRMService)])
.prefix(1)
.connect(for: self.littleBT)
// .sink( ...
</code></pre>
<h3 id='read' class='heading'>Read</h3>

<p>To read is simple as:</p>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
           .read(for: self.littleBT, from: hrmSensorChar)
           .sink(receiveCompletion: { (result) in
               print("Result: \(result)")
               switch result {
               case .finished:
                   break
               case .failure(let error):
                   print("Error while changing sensor position: \(error)")
                   break
               }

           }) { (value: HeartRateSensorPositionResponse) in // Specify the concrete type
               print("Value: \(value)")
       }
       .store(in: &amp;disposeBag)
</code></pre>

<p>Note that to make the compiler understand the generic type of the function at the next step you probably need to specify the concrete type.</p>
<h3 id='write' class='heading'>Write</h3>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
          .write(for: self.littleBT, to: hrmControlPointChar, value: UInt8(0x01))
          .sink(receiveCompletion: { (result) in
              print("Result: \(result)")
              switch result {
              case .finished:
                  break
              case .failure(let error):
                  print("Error while writing control point: \(error)")
                  break
              }

          }) {}
      .store(in: &amp;disposeBag)
</code></pre>
<h3 id='listen' class='heading'>Listen</h3>

<p>To listen directly (enable and get results) from a characteristic:</p>
<pre class="highlight plaintext"><code>StartLittleBlueTooth
.startListen(for: self.littleBT, from: hrmRateChar)
.sink(receiveCompletion: { (result) in
        print("Result: \(result)")
        switch result {
        case .finished:
            break
        case .failure(let error):
            print("Error while trying to listen: \(error)")
        }
}) { (value: HeartRateMeasurementResponse) in
    self.hrmRateLabel.text = String(value.value)
}
.store(in: &amp;disposeBag)
</code></pre>

<p>To enable listen on a characteristic and attach before or later on  the <code>littleBT.listenPublisher</code> </p>
<pre class="highlight plaintext"><code>.enableListen(for: self.littleBT, from: charateristicOne)
</code></pre>

<p>To stop:</p>
<pre class="highlight plaintext"><code>.disableListen(for: self.littleBT, from: hrmRateChar)
</code></pre>
<h3 id='disconnect' class='heading'>Disconnect</h3>

<p>To disconnect from a device simply call:</p>
<pre class="highlight plaintext"><code>.disconnect(for: self.littleBT)
</code></pre>
<h3 id='note' class='heading'>Note</h3>

<p>To start operations using a publisher or a custom operator you <strong>must attach a subscriber</strong>.
And the result <code>AnyCancellable</code> must be store in a property or in a disposebag, you must guarantee the existance of the pipeline untill the end.</p>
<h2 id='documentation' class='heading'>DOCUMENTATION</h2>

<p>Jazzy doc is available <a href="https://drama999.github.io/LittleBlueTooth/index.html">here</a></p>
<h2 id='sample-application' class='heading'>SAMPLE APPLICATION</h2>

<p>A sample application can be download <a href="https://github.com/DrAma999/LittleBlueToothTestApp">here</a>. It requires also to adownload an application for macOS or iOS to simulate a heart rate monitor.</p>
<h2 id='roadmap' class='heading'>ROADMAP</h2>

<ul>
<li>[x] SwiftPM support</li>
<li>[x] State preservation and state restoration</li>
<li>[ ] Improve code coverage</li>
<li>[x] <code>CBManager</code> and <code><a href="Typealiases.html#/CBPeripheral">CBPeripheral</a></code> extraction</li>
<li>[x] Add support to: <strong>macOS</strong>, <strong>watchOS</strong>, <strong>tvOS</strong>, <strong>macOS catalyst</strong></li>
<li>[x] Implement custom operator</li>
</ul>
<h2 id='issues' class='heading'>ISSUES</h2>

<p>Please use Github, explaining what you did, how you did, what you expect and what you get.</p>
<h2 id='contributing' class='heading'>CONTRIBUTING</h2>

<p>Since I&rsquo;m working on this project in my spare time any help is appreciated.
Feel free to make a pull request.</p>
<h2 id='thanks' class='heading'>THANKS</h2>

<p>This work would have never been possible without looking at the library <a href="https://github.com/Polidea/RxBluetoothKit">RXBluetooth Kit</a> from Polidea (check it if you need to deploy on lower target) and <a href="https://github.com/steamclock/bluejay">Bluejay</a>, another amazing library for iOS.</p>

<p>Icon made by  <a href="https://www.flaticon.com/authors/freepik">Freepik</a>  from  <a href="http://www.flaticon.com/">www.flaticon.com</a> </p>
<h2 id='license' class='heading'>LICENSE</h2>

<p>MIT License</p>

<p>Copyright &copy; 2020 Andrea Finollo</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &ldquo;Software&rdquo;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2022 <a class="link" href="https://www.facebook.com/CloudInTouchLabs" target="_blank" rel="external noopener">Andrea Finollo</a>. All rights reserved. (Last updated: 2022-07-08)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external noopener">jazzy ♪♫ v0.14.2</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external noopener">Realm</a> project.</p>
    </section>
  </body>
</html>
